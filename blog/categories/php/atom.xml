<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Php | 老虎的眼睛]]></title>
  <link href="http://www.wanghd.com/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://www.wanghd.com/"/>
  <updated>2013-07-02T13:40:08+08:00</updated>
  <id>http://www.wanghd.com/</id>
  <author>
    <name><![CDATA[王惠达 huida wanghuida]]></name>
    <email><![CDATA[wanghuida258@yahoo.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[php图片处理ubuntu配置]]></title>
    <link href="http://www.wanghd.com/blog/2013/07/02/phptu-pian-chu-li-ubuntupei-zhi/"/>
    <updated>2013-07-02T10:08:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2013/07/02/phptu-pian-chu-li-ubuntupei-zhi</id>
    <content type="html"><![CDATA[<ul>
<li>安装imagemagick 和图片库</li>
</ul>


<p>```
sudo apt-get install libpng12-0 libpng12-dev libpng3
sudo apt-get install libtiff4 libtiff4-dev libtiffxx0c2
sudo apt-get install libjasper-dev libjpeg-dev
sudo apt-get install imagemagick</p>

<h1>显示 imagemagick 支持的图片类型</h1>

<p>convert -list format
convert -list configure
```</p>

<!-- more -->


<ul>
<li>安装 php和php模块</li>
</ul>


<p><code>
sudo apt-get install php5 php5-curl php5-gd php5-mysql php5-fpm php5-imagick php5-xcache php5-cli php5-common php5-mcrypt
</code></p>

<ul>
<li>配置xcache</li>
</ul>


<p><code>
xcache.size  =  64M
xcache.count =  8
xcache.slots =  16K
</code></p>

<ul>
<li>配置fpm里的php.ini</li>
</ul>


<p><code>
error_log = /tmp/php-error.log
post_max_size = 20M
upload_max_filesize = 20M
date.timezone = PRC
</code></p>

<ul>
<li><p>配置fpm
<code>
user = ***
group = ***
listen = 127.0.0.1:10001
pm.max_children = 16
</code></p></li>
<li><p>安装配置nginx请参考<a href="/blog/2013/03/31/nginx-pei-zhi-mo-ban/">这篇文章</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yii 隐藏index.php RESTful nginx配置]]></title>
    <link href="http://www.wanghd.com/blog/2013/05/24/yii-yin-cang-index-dot-php/"/>
    <updated>2013-05-24T14:36:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2013/05/24/yii-yin-cang-index-dot-php</id>
    <content type="html"><![CDATA[<ol>
<li>默认yii不使用RESTful的url，比如: index.php/news/list?category=12</li>
<li><p>通过简单的配置可以美化url，比如：/news/list/category/12</p></li>
<li><p>修改main.php配置</p></li>
</ol>


<p>```php
&lt;?php</p>

<p>'components' => array (</p>

<pre><code>'urlManager'=&gt;array(
    'urlFormat'=&gt;'path',
    'showScriptName'=&gt;false,
    'rules'=&gt;array(),
),
</code></pre>

<p>)</p>

<p>```</p>

<ul>
<li>修改nginx.php配置</li>
</ul>


<!-- more -->


<p>```
server {</p>

<pre><code>listen          11111;
index           index-test.php index.html;
root            /xxxxxx/xxxxx/project/yii-test;
charset         utf-8;

client_max_body_size 20m;

# 是否存在文件，不存在就rewrite index-test.php，生产应该是index.php
location / {
    if (!-e $request_filename){
        rewrite ^/(.*) /index-test.php last;
    }
}

# 缓存资源文件
location ~* \.(js|css|png|jpg|jpeg|gif|ico|swf)$ {
    expires 24h;
}

# 定义path_info，并交给fpm处理
location ~ \.php {
    fastcgi_split_path_info     ^(.+\.php)(/.*)$;
    fastcgi_param               PATH_INFO                               $fastcgi_script_name;
    include                     /usr/local/etc/nginx/fastcgi.conf;
    fastcgi_pass                127.0.0.1:10001;
    fastcgi_index               index-test.php;
    expires                     off;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yii 用户验证]]></title>
    <link href="http://www.wanghd.com/blog/2013/05/24/yii-yong-hu-yan-zheng/"/>
    <updated>2013-05-24T12:39:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2013/05/24/yii-yong-hu-yan-zheng</id>
    <content type="html"><![CDATA[<ol>
<li>yii用户验证其实很简单，但是网络上的文章都写的不够详细【包括官方的】</li>
<li>先介绍一下基于session的用户验证</li>
<li>用cookie让用户可以保持状态，再介绍一下安全性</li>
</ol>


<!-- more -->


<ul>
<li>main.php 配置登录页面</li>
</ul>


<p>```php
&lt;?php</p>

<p>'components' => array (</p>

<pre><code>'user' =&gt; array (
    'loginUrl' =&gt; array('user/login'),
),
</code></pre>

<p>)
```</p>

<ul>
<li>在控制器中增加权限控制和规则</li>
</ul>


<p>```php
&lt;?php</p>

<p>class UserController extends CController
{</p>

<pre><code># 让控制器加入到权限控制
public function filters()
{
    return array(
        'accessControl',
    );
}

# 让edit,view这2个action访客无法直接使用，跳转到登录界面
public function accessRules()
{
    return array(
        array('deny',
            'actions'=&gt;array('edit', 'view'),
            'users'=&gt;array('?'),
        ),
    );
}

public function actionEdit() { var_dump('edit'); }
public function actionView() { var_dump('view'); }
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>创建继承CUserIdentity的用户标识类给登录时使用</li>
</ul>


<p>```php
&lt;?php</p>

<p>class UserIdentity extends CUserIdentity
{</p>

<pre><code>protected $_id;

public function authenticate()
{
    /*
        这里可以写判断是否有用户的逻辑

        需要存储到session里的数据可以这样写
        $this-&gt;setState('nickname', $member-&gt;nickname);
    */
    $this-&gt;_id = $member-&gt;user_id;
    return true;
}

public function getId()
{
    return $this-&gt;_id;
}
</code></pre>

<p>}
```</p>

<ul>
<li>用户登陆的控制器</li>
</ul>


<p>```php
&lt;?php</p>

<p>class UserController extends Controller
{</p>

<pre><code>private $req;

private $user;

public function actionLogin()
{
    $this-&gt;req = Yii::app()-&gt;request;
    $this-&gt;user = Yii::app()-&gt;user;

    $reason = '';
    if ($this-&gt;req-&gt;isPostRequest) {

        $email = $this-&gt;req-&gt;getPost('email','');
        $password = $this-&gt;req-&gt;getPost('password','');

        $identity = new UserIdentity($email, $password);
        if($identity-&gt;authenticate()) {
            $this-&gt;user-&gt;login($identity);
            $this-&gt;redirect($this-&gt;user-&gt;returnUrl);
        } else {
            $reason = $identity-&gt;errorMessage;
        }
    }
    $this-&gt;render('/login', array('reason'=&gt;$reason));
}
</code></pre>

<p>}</p>

<p>```</p>

<hr />


<ul>
<li>增加登录cookie保持用户登录状态，改完赶紧尝试一下吧</li>
</ul>


<p>```php
&lt;?php</p>

<h1>修改main.php,允许自动登录</h1>

<p>'user' => array (</p>

<pre><code>'allowAutoLogin' =&gt; true,
'loginUrl' =&gt; array('user/login'),
</code></pre>

<p>),</p>

<h1>修改UserController设置7天有效期</h1>

<p>$this->user->login($identity, 86400);
```</p>

<ul>
<li>不经问自己：这样的cookie安全吗？会不会被利用？</li>
</ul>


<p>```
1. 不应该把敏感信息保存到state里，比如密码
2. yii内部有cookie校验机制，改动的cookie是无法生效的，可以看下/protected/runtime/state.bin（这就是验证随机的key）
3. 想要知道yii内部生成key源码可以参考 CSecurityManager</p>

<p>protected function generateRandomKey()
{</p>

<pre><code>return sprintf('%08x%08x%08x%08x',mt_rand(),mt_rand(),mt_rand(),mt_rand());
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yii 文件日志]]></title>
    <link href="http://www.wanghd.com/blog/2013/05/23/yii-ri-zhi/"/>
    <updated>2013-05-23T15:12:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2013/05/23/yii-ri-zhi</id>
    <content type="html"><![CDATA[<ul>
<li>yii的文件日志默认在runtime下的application.log</li>
</ul>


<!-- more -->


<ul>
<li>yii配置文件日志和记录等级</li>
</ul>


<p>```php
&lt;?php</p>

<h1>main.php配置文件, 生产环境只记录error和warning</h1>

<p>'components' => array (</p>

<pre><code>'log'=&gt;array(
    'class'=&gt;'CLogRouter',
    'routes'=&gt;array(
        array(
            'class'=&gt;'CFileLogRoute',
            'levels'=&gt;'error, warning',
        ),
    ),
),
</code></pre>

<p>)</p>

<h1>test.php配置文件，线下测试所有的都记录下来</h1>

<p>'components' => array (</p>

<pre><code>'log'=&gt;array(
    'class'=&gt;'CLogRouter',
    'routes'=&gt;array(
        array(
            'class'=&gt;'CFileLogRoute',
            #trace内容很多，一般不开启，用info足够了
            'levels'=&gt;'info, profile, error, warning',
        ),
    ),
),
</code></pre>

<p>)</p>

<h1>记录日志, 1.log信息,2.等级,3.分类（分类自定义）</h1>

<p>Yii::log('info调试信息', CLogger::LEVEL_INFO, 'test.info');
Yii::log('profile调试信息', CLogger::LEVEL_PROFILE, 'test.profile');
Yii::log('warning调试信息', CLogger::LEVEL_WARNING, 'test.warning');
Yii::log('error调试信息', CLogger::LEVEL_ERROR, 'test.error');
```</p>

<ul>
<li>服务器异常错误，显示错误页面，这样的错误会记录到日志中（因为属于error, warning）</li>
</ul>


<p>```php
&lt;?php</p>

<h1>在main.php中配置errorHandler，统一处理异常</h1>

<p>'components' => array (</p>

<pre><code>'errorHandler' =&gt; array(
    'errorAction'=&gt;'site/error',
),
</code></pre>

<p>)</p>

<h1>在Site控制器里增加error的action，处理错误</h1>

<p>class SiteController extends Controller
{</p>

<pre><code>public function actionIndex()
{
    # 产生一个异常
    throw new CHttpException(500, '调用接口失败');
    $this-&gt;render('/index');
}

public function actionError()
{
    $error = Yii::app()-&gt;errorHandler-&gt;error;
    $params = array();
    if($error) {
        $params['code'] = $error['code'];
        $params['msg'] = $error['message'];
        $params['json'] = json_encode($error);
        $params['is_debug'] = YII_DEBUG;
    }
    $this-&gt;render('/error', $params);
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[游览器缓存解析]]></title>
    <link href="http://www.wanghd.com/blog/2013/01/18/you-lan-qi-huan-cun-jie-xi/"/>
    <updated>2013-01-18T19:32:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2013/01/18/you-lan-qi-huan-cun-jie-xi</id>
    <content type="html"><![CDATA[<h3>游览器缓存：可以通过如下四种方式进行设置</h3>

<ol>
<li>Expire: 直接设置过期时间(不做详细解释，用Cache-Control更好)</li>
<li>Cache-Control: HTTP 1.1用Cache-Control代替Expire，Cache-Control比Expire更方便，功能更多。不需要访问服务器端</li>
<li>Last-Modified: 用来设置最后更新时间。需要访问服务器端，如果没有更新直接使用304，节省网络流量和网络传输时间</li>
<li>ETag: 用来设置唯一标识。需要访问服务器端，和last-modified一样</li>
</ol>


<!-- more -->


<h3>Cache-Control</h3>

<p><code>php
&lt;?php
header("Cache-Control: max-age=120, must-revalidate");
echo "cache cache";  
</code></p>

<p><img src="/images/post/cache-control.jpg" title="cache-control" alt="cache-control" /></p>

<ul>
<li>刷新(cmd + r)，强刷(shift + cmd + r)，都会访问服务器, 因为这两种方式游览器会绕过本地缓存。尝试打开一个新的tab访问，没有和服务器交互。</li>
<li>windows用户的刷新(F5)，强刷(ctrl + F5)</li>
</ul>


<h3>Last-Modified</h3>

<p>```
&lt;?php</p>

<p>$time = strtotime('2013-01-18');
header("Last-Modified: " . gmdate("D, d M Y H:i:s", $time) . " GMT");</p>

<p>$modified_since = isset($<em>SERVER['HTTP_IF_MODIFIED_SINCE']) ? $</em>SERVER['HTTP_IF_MODIFIED_SINCE'] : false;
if ($modified_since) {</p>

<pre><code>$modified_since = strtotime($modified_since);
</code></pre>

<p>}</p>

<p>if ($time == $modified_since) {</p>

<pre><code>echo "hit"; 
</code></pre>

<p>} else {</p>

<pre><code>echo "no hit";
</code></pre>

<p>}
```</p>

<p><img src="/images/post/last-modified.jpg" title="last-modified" alt="last-modified" /></p>

<p><img src="/images/post/last-modified-ret.jpg" title="last-modified-ret" alt="last-modified-ret" /></p>

<ul>
<li>第一次访问显示no hit，刷新则命中缓存显示hit(一般304处理，我这里只是举例)。强刷则会显示no hit，可见游览器的强刷是有特别用处的</li>
</ul>


<h3>ETag</h3>

<p>```
&lt;?php</p>

<p>$etag = 'test-etag';
$none_match = @$_SERVER['HTTP_IF_NONE_MATCH'];</p>

<p>if ($none_match == $etag) {</p>

<pre><code>header("HTTP/1.1 304 Not Modified", true, 304); 
exit;
</code></pre>

<p>}</p>

<p>header("ETag: {$etag}");
echo "test ok!";
```</p>

<p><img src="/images/post/etag.jpg" title="etag" alt="etag" /></p>

<p><img src="/images/post/etag304.jpg" title="etag304" alt="etag304" /></p>

<ul>
<li>第一次访问http返回200，显示test ok!。刷新http返回304，使用本地缓存，显示test ok!。强刷则绕过本地缓存，http返回200，可见和last-modified一样</li>
</ul>

]]></content>
  </entry>
  
</feed>
