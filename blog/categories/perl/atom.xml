<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | 惠达的小宅]]></title>
  <link href="http://www.wanghd.com/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://www.wanghd.com/"/>
  <updated>2012-11-25T19:31:26+08:00</updated>
  <id>http://www.wanghd.com/</id>
  <author>
    <name><![CDATA[王惠达 huida wanghuida]]></name>
    <email><![CDATA[wanghuida258@yahoo.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MogileFS安装配置]]></title>
    <link href="http://www.wanghd.com/blog/2012/11/22/mogilefsan-zhuang-pei-zhi/"/>
    <updated>2012-11-22T17:19:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/11/22/mogilefsan-zhuang-pei-zhi</id>
    <content type="html"><![CDATA[<h3>基本介绍</h3>

<ul>
<li>mogilefs是一个分布式的文件系统解决方案</li>
<li>特点是:无单点失效的问题，自动复制无需raid，easy的命名空间，自修复机制，成熟的管理工具，源码清晰推荐阅读</li>
</ul>


<!-- more -->


<h3>安装基本组件</h3>

<p>```bash
yum groupinstall "Development Tools"</p>

<h1>cpan是perl的包管理工具</h1>

<p>yum install cpan
```</p>

<h3>安装mogilefs</h3>

<p>```bash</p>

<h1>进入cpan,初始化直接自动就好</h1>

<p>cpan</p>

<blockquote><p>install IO::AIO
install MogileFS::Client
install MogileFS::Utils</p>

<h1>如果有问题直接用force install</h1>

<p>install MogileFS::Server
```</p></blockquote>

<h3>安装配置mysql</h3>

<p>```bash</p>

<h1>安装mysql</h1>

<p>yum install mysql mysql-server
mysqladmin -u root password 123456</p>

<h1>进入mysql,新建mogile用户</h1>

<p>mysql -uroot -p123456
mysql> create database mogilefs;
mysql> grant all on mogilefs.* to mogile@localhost identified by '123456';
mysql> flush privileges;</p>

<h1>导入mogilefs表</h1>

<p>mogdbsetup --dbpass=123456 --yes
```</p>

<h3>mogilefs配置</h3>

<ul>
<li>mogilefsd配置</li>
</ul>


<p>```bash</p>

<h1>/etc/mogilefs是默认的配置路径，-c可以修改</h1>

<p>mkdir -p /etc/mogilefs
cd /etc/mogilefs
vim mogilefsd.conf</p>

<h1>内容如下</h1>

<p>pidfile = /tmp/mogilefsd.pid    #存放pid
daemonize = 1                   #守护进程</p>

<p>db_dsn  = DBI:mysql:mogilefs:127.0.0.1  #数据库配置
db_user = mogile
db_pass = 123456</p>

<p>conf_port = 7001                #监听端口
node_timeout = 2                #节点超时时间
rebalance_ignore_missing = 1    #rebalance时会删除文件，删除时如果找不到文件不报错直接跳过</p>

<p>query_jobs = 20                 #正真处理请求的job个数
delete_jobs = 3                 #处理删除队列的job个数
replicate_jobs = 5              #处理复制队列的job个数
reaper_jobs = 1                 #设备设置为dead后，处理补救工作的job个数</p>

<pre><code>                            #其实还有其他job，默认为1个
</code></pre>

<p>```</p>

<ul>
<li>mogstored配置</li>
</ul>


<p>```bash</p>

<h1>设置文件存储路径，不要忘记修改拥有者</h1>

<p>mkdir -p /var/mogdata
adduser --gid daemon mogile
chown mogile.daemon /var/mogdata
vim mogstored.conf</p>

<h1>内容如下</h1>

<p>httplisten = 0.0.0.0:7500       #文件存储端口
mgmtlisten = 0.0.0.0:7501       #监控磁盘状态端口
docroot = /var/mogdata          #文件存储路径</p>

<p>pidfile = /tmp/mogstored.pid    #存储pid
daemonize = 1                   #守护进程
```</p>

<h3>启动mogilefs</h3>

<p>```bash
vim /etc/security/limits.conf</p>

<h1>内容如下，让mogile可以打开更多的连接数</h1>

<p>mogile soft nofile 65535
mogile hard nofile 65535</p>

<h1>切换用户启动</h1>

<p>su mogile -c 'mogstored'
su mogile -c 'mogilefsd'</p>

<h1>验证已经启动成功</h1>

<p>ps auxf | grep mogile
mogadm check</p>

<p>```</p>

<h3>已经安装好了，接来应该做点什么呢</h3>

<ul>
<li>学习mogadm指令，因为mogadm是必会工具</li>
<li>试着client连接mogilefsd存储文件吧</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Time::HiRes介绍]]></title>
    <link href="http://www.wanghd.com/blog/2012/11/22/time-hiresjie-shao/"/>
    <updated>2012-11-22T17:18:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/11/22/time-hiresjie-shao</id>
    <content type="html"><![CDATA[<h3>Time::HiRes库介绍</h3>

<ul>
<li>HiRes是high resolution的简写，译为高分辨率</li>
<li>HiRes其实是提供一些更高精度的alarm, sleep, gettimeofday, interval timers</li>
</ul>


<!-- more -->


<h3>usleep，nanosleep实例</h3>

<ul>
<li>usleep参数是微妙</li>
<li>nanosleep参数是纳秒</li>
</ul>


<p><code>perl
Time::HiRes::usleep(100_000);
print "100 milliseconds\n";
Time::HiRes::nanosleep(1000_000_000);
print "1 seconds\n";
</code></p>

<h3>ualarm实例</h3>

<ul>
<li>ualarm(0)会撤销警告信号</li>
</ul>


<p>```perl
eval {</p>

<pre><code>local $SIG{ALRM} = sub { die "receive signal\n" };
Time::HiRes::ualarm 1000_000;
sleep 2;
print "never print";
</code></pre>

<p>};</p>

<p>if($@) {</p>

<pre><code>print $@;
</code></pre>

<p>}</p>

<p>eval {</p>

<pre><code>local $SIG{ALRM} = sub { die "receive signal\n" };
Time::HiRes::ualarm 2000_000;
sleep 1;
Time::HiRes::ualarm 0; #cancel alarm
</code></pre>

<p>};</p>

<p>if($@) {</p>

<pre><code>print $@;
</code></pre>

<p>}else{</p>

<pre><code>print "cancel alarm signal\n";
</code></pre>

<p>}  <br/>
```</p>

<h3>tv_interval和gettimeofday实例</h3>

<ul>
<li>tv_interval返回两个gettimeofday引用相差的秒数</li>
<li>省略tv_interval的第二个参数，会自动使用当前时间代替</li>
</ul>


<p><code>perl
my @start = Time::HiRes::gettimeofday;
print Dumper(\@start);
sleep(4);
my $diff = Time::HiRes::tv_interval(\@start);
print "$diff\n";
</code></p>

<h3>setitimer实例</h3>

<ol>
<li>ITIMER_REAL: 真实时间</li>
<li>ITIMER_VIRTUAL: 用户时间</li>
<li><p>ITIMER_PROF: 系统时间</p></li>
<li><p>getitimer可以取得setitimer还有多久开始执行</p></li>
</ol>


<p>```perl
use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );
$SIG{VTALRM} = sub { print time, "\n" };
setitimer(ITIMER_VIRTUAL, 3.5, 1);
while(1){ }</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修复mogilefs目录owner]]></title>
    <link href="http://www.wanghd.com/blog/2012/11/22/xiu-fu-mogilefsmu-lu-owner/"/>
    <updated>2012-11-22T17:16:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/11/22/xiu-fu-mogilefsmu-lu-owner</id>
    <content type="html"><![CDATA[<h3>什么情况会导致mogilefs的数据目录owner不正确</h3>

<ul>
<li>直接使用root启动mogstored会导致增加的文件和文件夹为root</li>
<li>重新用mogile启动mogstored后，mogile用户无法删除root的文件，最终delete队列无法处理</li>
</ul>


<h3>如何处理</h3>

<ol>
<li>直接chown -R，这是最直接的方法，如果1T的磁盘被这样操作，会10小时util为100</li>
<li>自己写一个脚本慢处理，脚本思路如下</li>
</ol>


<!-- more -->


<p>```perl
package MtChown;</p>

<p>use strict;
use warnings;
use Data::Dumper;
use Carp;
use Time::HiRes;</p>

<p>sub run {</p>

<pre><code>my ($dir,$user) = @_;

if(!defined($dir) || !defined($user)){
    print "please set option [-D|--dir -u|--user]\n"; 
    return 0; 
}
$dir =~ s/(.+)\/$/$1/i;

croak("[$dir] isn't a directory or file") unless (-f $dir or -d $dir);
my ($login,$pass,$uid,$gid) = getpwnam($user) or die "$user not in passwd file";
carp("$uid,$gid");
process($dir,$uid,$gid);
return 1;
</code></pre>

<p>}</p>

<p>sub process {</p>

<pre><code>my ($dir,$u,$g) = @_;
if (-d $dir) {
    opendir(FILE,$dir) or croak("opendir error [$dir]");
    my @files = readdir(FILE);
    closedir(FILE);
    foreach (@files) {
        next if ($_ eq '.' || $_ eq '..');
        my $tmp_dir = "$dir/$_";
        if (-d $tmp_dir) {
            process($tmp_dir,$u,$g)
        }else {
            chowner($u,$g,$tmp_dir);
        }
    }
}
chowner($u,$g,$dir);
</code></pre>

<p>}</p>

<p>sub chowner {</p>

<pre><code>my ($u,$g,$dir) = @_;
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($dir);
if($u != $uid || $g != $gid){
    my $ret = chown $u,$g,($dir);
    $ret &lt;= 0 ? carp("chown [$u,$g,$dir] error") : carp("chown [$u,$g,$dir] success");
}
my $microsec = 50_000;
Time::HiRes::usleep($microsec);
</code></pre>

<p>}</p>

<p>1;
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[perl父进程监听，子进程工作实例]]></title>
    <link href="http://www.wanghd.com/blog/2012/11/08/perlfu-jin-cheng-jian-ting-zi-jin-cheng-gong-zuo-shi-li/"/>
    <updated>2012-11-08T22:15:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/11/08/perlfu-jin-cheng-jian-ting-zi-jin-cheng-gong-zuo-shi-li</id>
    <content type="html"><![CDATA[<ol>
<li>构造后台进程</li>
<li>主进程监到连接，创建子进程接收消息并处理消息</li>
<li>主进程继续监听，同时非阻塞的回收子进程</li>
</ol>


<!-- more -->


<p>```perl</p>

<h1>!/usr/bin/perl</h1>

<p>use warnings;
use strict;
use IO::Socket;
use Socket qw(SO_KEEPALIVE);
use IO::Poll;</p>

<h1>POSIX标准是必须要的，否则waitpid会阻塞住</h1>

<p>use POSIX;
use Carp;
use Errno  qw(EINPROGRESS EWOULDBLOCK EISCONN ENOTSOCK</p>

<pre><code>          EPIPE EAGAIN EBADF ECONNRESET ENOPROTOOPT);
</code></pre>

<p>$| = 1;
daemonize();</p>

<p>my $server = IO::Socket::INET->new(LocalAddr => "0.0.0.0:5678",</p>

<pre><code>                               Type      =&gt; SOCK_STREAM,
                               Proto     =&gt; 'tcp',
                               Blocking  =&gt; 0,
                               Reuse     =&gt; 1,
                               Listen    =&gt; 1024 )
or die "Error creating socket: $@\n";
</code></pre>

<p>$server->sockopt(SO_KEEPALIVE, 1);</p>

<p>while(1) {</p>

<pre><code>while(my $pid = waitpid -1, WNOHANG) {
    #print "child[$pid] closed\n" if($pid &gt; 0);
    last unless $pid &gt; 0;  
}

if(my $csock = $server-&gt;accept) {                                                                                                                           
    my $pid = fork;

    if($pid){
        close($csock);
        undef $csock;
    }else{
        $0 .= " [perl child]"; 
        while(1) {
            my $buf;
            my $len = sysread($csock, $buf, 1048576, 0);
            work($buf); 
            last if (!$len &amp;&amp; $! != EWOULDBLOCK);
        }
        exit 0;
    }
}
</code></pre>

<p>}</p>

<h1>子进程的工作</h1>

<p>sub work{</p>

<pre><code>print @_."\n";
</code></pre>

<p>}</p>

<p>sub daemonize {</p>

<pre><code>my($pid, $sess_id, $i);

if ($pid = fork) { exit 0; }

croak "Cannot detach from controlling terminal"
    unless $sess_id = POSIX::setsid();

$SIG{'HUP'} = 'IGNORE';
if ($pid = fork) { exit 0; }

chdir "/";

umask 0;
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mogilefs删除队列]]></title>
    <link href="http://www.wanghd.com/blog/2012/11/06/mogilefsshan-chu-dui-lie/"/>
    <updated>2012-11-06T19:31:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/11/06/mogilefsshan-chu-dui-lie</id>
    <content type="html"><![CDATA[<h3>遇到的问题</h3>

<ul>
<li>发现file_to_delete2队列表里有500万记录，奇怪这些文件为什么要删除？心里不踏实，寻找根源...</li>
<li>在队列中随便拿一个fid，在file表里查竟然是空的，再找file_on表竟然有数据...</li>
</ul>


<h3>什么时候会插入fid到删除队列呢</h3>

<ol>
<li>cmd_create_close时，如果连接终端，文件大小等不正确，会增加到删除队列</li>
<li>cmd_create_close时，如果同一domain下key已经存在，那么会去删除原有的文件(两份文件key相同，但是fid不同，我的问题就出在这)</li>
<li>mogdelete工具会删除memcache和file表的文件记录，并运用删除队列删除磁盘上的文件和file_on表</li>
<li>client调用delete方法，和mogdelete一样</li>
</ol>


<!-- more -->


<h3>cmd_create_close逻辑</h3>

<ul>
<li>mogilefs上传文件的逻辑是先问tracker拿文件存储路径，然后上传文件到一个storage，最后调用cmd_create_close方法插入数据记录和replicate队列</li>
</ul>


<p>```perl
sub cmd_create_close {</p>

<pre><code>my MogileFS::Worker::Query $self = shift;
my $args = shift;

# has to be filled out for some plugins
$args-&gt;{dmid} = $self-&gt;check_domain($args)
    or return $self-&gt;err_line('domain_not_found');

# call out to a hook that might modify the arguments for us
# 调用插件用的钩子，一般是没的
MogileFS::run_global_hook('cmd_create_close', $args);

# late validation of parameters
# 设置下面使用的变量
my $dmid  = $args-&gt;{dmid};
my $key   = $args-&gt;{key};
my $fidid = $args-&gt;{fid}    or return $self-&gt;err_line("no_fid");
my $devid = $args-&gt;{devid}  or return $self-&gt;err_line("no_devid");
my $path  = $args-&gt;{path}   or return $self-&gt;err_line("no_path");
my $checksum = $args-&gt;{checksum};

if ($checksum) {
    $checksum = eval { MogileFS::Checksum-&gt;from_string($fidid, $checksum) };
    return $self-&gt;err_line("invalid_checksum_format") if $@;
}    

# 初始化fid和dfid对象
my $fid  = MogileFS::FID-&gt;new($fidid);
my $dfid = MogileFS::DevFID-&gt;new($devid, $fid);

# is the provided path what we'd expect for this fid/devid?
# 验证是否为伪造路径
return $self-&gt;err_line("bogus_args")
    unless $path eq $dfid-&gt;url;
my $sto = Mgd::get_store();

# find the temp file we're closing and making real.  If another worker
# already has it, bail out---the client closed it twice.
# this is racy, but the only expected use case is a client retrying.
# should still be fixed better once more scalable locking is available.
# 取得零时文件数据,并删除掉
my $trow = $sto-&gt;delete_and_return_tempfile_row($fidid) or
    return $self-&gt;err_line("no_temp_file");

# Protect against leaving orphaned uploads.
# 定义错误函数，可以看到$fid-&gt;delete会删除file表记录并插入删除队列
my $failed = sub {
    $dfid-&gt;add_to_db;
    $fid-&gt;delete;
};

# 验证设备
unless ($trow-&gt;{devids} =~ m/\b$devid\b/) {
    $failed-&gt;();
    return $self-&gt;err_line("invalid_destdev", "File uploaded to invalid dest $devid. Valid devices were: " . $trow-&gt;{devids});
}

# if a temp file is closed without a provided-key, that means to
# delete it.
# 验证key
unless (defined $key &amp;&amp; length($key)) {
    $failed-&gt;();
    return $self-&gt;ok_line;
}

# get size of file and verify that it matches what we were given, if anything
my $httpfile = MogileFS::HTTPFile-&gt;at($path);
my $size = $httpfile-&gt;size;

# size check is optional? Needs to support zero byte files.
# 验证文件大小
$args-&gt;{size} = -1 unless $args-&gt;{size};
if (!defined($size) || $size == MogileFS::HTTPFile::FILE_MISSING) {
    # storage node is unreachable or the file is missing
    my $type    = defined $size ? "missing" : "cantreach";
    my $lasterr = MogileFS::Util::last_error();
    $failed-&gt;();
    return $self-&gt;err_line("size_verify_error", "Expected: $args-&gt;{size}; actual: 0 ($type); path: $path; error: $lasterr")
}

if ($args-&gt;{size} &gt; -1 &amp;&amp; ($args-&gt;{size} != $size)) {
    $failed-&gt;();
    return $self-&gt;err_line("size_mismatch", "Expected: $args-&gt;{size}; actual: $size; path: $path")
}

# checksum validation is optional as it can be very expensive
# However, we /always/ verify it if the client wants us to, even
# if the class does not enforce or store it.
# 校验和
if ($checksum &amp;&amp; $args-&gt;{checksumverify}) {
    my $alg = $checksum-&gt;hashname;
    my $actual = $httpfile-&gt;digest($alg, sub { $self-&gt;still_alive });
    if ($actual ne $checksum-&gt;{checksum}) {
        $failed-&gt;();
        $actual = "$alg:" . unpack("H*", $actual);
        return $self-&gt;err_line("checksum_mismatch",
                       "Expected: $checksum; actual: $actual; path: $path");
    }
}
# see if we have a fid for this key already
# 关键的来了，如果在同一个domain下有相同的key，那么删除该文件的file表记录，并插入delete队列
my $old_fid = MogileFS::FID-&gt;new_from_dmid_and_key($dmid, $key);
if ($old_fid) {
    # Fail if a file already exists for this fid.  Should never
    # happen, as it should not be possible to close a file twice.
    return $self-&gt;err_line("fid_exists")
        unless $old_fid-&gt;{fidid} != $fidid;

    $old_fid-&gt;delete;
}

# TODO: check for EIO?

# insert file_on row
# 以上都没有问题，那么就确认保存文件到数据库
# 保存到file_on表
$dfid-&gt;add_to_db;

$checksum-&gt;maybe_save($dmid, $trow-&gt;{classid}) if $checksum;

# 保存到file表 
$sto-&gt;replace_into_file(
                        fidid   =&gt; $fidid,
                        dmid    =&gt; $dmid,
                        key     =&gt; $key,
                        length  =&gt; $size,
                        classid =&gt; $trow-&gt;{classid},
                        devcount =&gt; 1,
                        );

# mark it as needing replicating:
# 插入文件到replicate队列 
$fid-&gt;enqueue_for_replication();

# call the hook - if this fails, we need to back the file out
# 调用钩子
my $rv = MogileFS::run_global_hook('file_stored', $args);
if (defined $rv &amp;&amp; ! $rv) { # undef = no hooks, 1 = success, 0 = failure
    $fid-&gt;delete;                                                                                                                                                           
    return $self-&gt;err_line("plugin_aborted");
}
# all went well, we would've hit condthrow on DB errors
# 返回正确结果
return $self-&gt;ok_line;
</code></pre>

<p>}  <br/>
```</p>

<h3>总结为什么会出现这种现象</h3>

<ul>
<li>当在同一个domain下，上传相同key的文件，之前的文件会被删除，但是两个文件的fid是不同的</li>
<li>$fid->delete这个操作实际是删除memcache和file表数据，file_on表和磁盘上的文件交给队列来处理</li>
<li>作者考虑到删除文件是比较耗时的操作，所以交给队列慢慢处理，才会导致file表里没数据，但是file_on上仍有数据</li>
<li>如果可能，尽量避免上传相同的key，这样可以减少对db的读写操作(我准备优化)</li>
</ul>

]]></content>
  </entry>
  
</feed>
