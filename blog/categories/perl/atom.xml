<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | 惠达的小宅]]></title>
  <link href="http://www.wanghd.com/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://www.wanghd.com/"/>
  <updated>2012-11-04T00:39:47+08:00</updated>
  <id>http://www.wanghd.com/</id>
  <author>
    <name><![CDATA[王惠达 huida wanghuida]]></name>
    <email><![CDATA[wanghuida258@yahoo.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MogileFS详解]]></title>
    <link href="http://www.wanghd.com/blog/2012/10/23/mogilefsxiang-jie/"/>
    <updated>2012-10-23T22:48:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/10/23/mogilefsxiang-jie</id>
    <content type="html"><![CDATA[<ul>
<li>经过一个月的实际应用，我想是时候应该总结一下mogilefs的使用了，如果想和作者交流参考<a href="/blog/2012/10/13/irc-irssishi-yong-jiao-cheng/">IRC教程</a></li>
</ul>


<h3>MogileFS简介</h3>

<blockquote><p>MogileFS是一个<code>开源</code>的<code>分布式文件系统</code>，配合cdn和squid，性能非常好(<code>15亿</code>文件没问题，其他数据不方便透露)</p>

<p>他由下面几个部分组成:</p></blockquote>

<p><img src="/images/post/mogilefs-summary.jpg" title="mogilefs-summary" alt="mogilefs-summary" /></p>

<ol>
<li>memcache：用来缓存查询结果，降低db压力</li>
<li>mogilefsd：就是tracker，用来接收请求并交给子进程(job)处理</li>
<li>mogstored：监控磁盘状态和文件的实际存储</li>
<li>client：支持perl，java，ruby，php，python</li>
<li>mysql：存储记录</li>
<li>util：日常维护管理的工具集</li>
<li>telnet：监控tracker，实时调整job的工具</li>
</ol>


<!-- more -->


<h3>Mogstored</h3>

<blockquote><p>监控磁盘状态和文件的实际存储,启动mogstored会发现包含2个端口，默认的7501和7500</p>

<blockquote><p>7501用来监控磁盘状态</p>

<p>7500用来处理实际的文件存储</p></blockquote></blockquote>

<p><img src="/images/post/mogilefs-mogstored.jpg" title="mogilefs-mogstored" alt="mogilefs-mogstored" /></p>

<h4>问题总结</h4>

<ul>
<li>原本我一直以为mogstored自己实现了一套文件存储，但实际上不是。它使用的是WebDav，所以可以使用nginx代替默认的perlbal，实际用下来nginx更稳定</li>
<li>WebDav：一种基于 HTTP 1.1协议的通信协议.它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，例如PUT(新增)、DELETE(删除)、MKCOL(创建目录)</li>
<li>在mogstored的使用上，犯过一个错误：直接使用root启动mogstored，那么创建的文件夹和文件都是属于root，导致delete job无法删除该文件（同事陈磊发现）</li>
<li>文件存储规则：/dev-xx/0/123/456/789/0123456789.fid，fid不足十位补0，通过fid进行切割变为目录，即分散又效率</li>
</ul>


<h3>Mogilefsd</h3>

<blockquote><p>主进程负责接受请求，分配任务给子进程执行,下面详细介绍一下他的子进程</p></blockquote>

<ol>
<li>query：处理主进程分配的请求，包括util和tool的指令</li>
<li>delete：根据删除队列对文件进行删除操作</li>
<li>replicate：复制文件直到满足mindevcount(文件复制几份)</li>
<li>fsck：检查磁盘文件和数据库是否匹配，不匹配时进行补救</li>
<li>monitor：监控子进程的状态，实时调整子进程个数</li>
<li>reaper：监控dead的磁盘，及时补救，把文件加到replicate queue</li>
<li>jobmaster：读取delete,replicate,rebalance,fsck队列，告诉主进程，主进程再交给对应的子进程处理</li>
</ol>


<h4>问题总结</h4>

<ul>
<li>query新建文件时，用剩余容量作权重，随机选择。所以新加入一块设备时，极有可能将成为热点设备，最好是一组设备一起加</li>
<li>如果设备出现问题，直接格式化后直接使用会导致数据库记录还在，文件丢失，最终fsck和replicate队列堆积，正确的做法是把设备状态设置为dead，然后格式化用一个新的devid使用</li>
<li>如果确定磁盘损坏，就一定要设置dead状态，reaper会自动补救</li>
</ul>


<h3>Memcache</h3>

<blockquote><p>用来缓存查询结果，降低db压力，query内部存放<code>key对应的fid</code>和<code>fid对应的设备</code></p></blockquote>

<h4>问题总结</h4>

<ul>
<li>db压力下不来的原因是客户端取得文件时没有设置noverify参数，如果确定要使用memcache就一定要设置noverify，否则不使用memcache</li>
</ul>


<h3>Mysql</h3>

<blockquote><p>用来存储记录，当然也可以使用其他数据库</p></blockquote>

<ol>
<li>host表：存储主机信息</li>
<li>device表：存储设备，一般单个device对应一块磁盘，也可以不这样</li>
<li>domain表：定义域，单个域下key唯一</li>
<li>class表：文件存放策略，包括份数，复制策略，校验和</li>
<li>server_settings表：部分配置信息和job配置信息</li>
<li>file表：文件信息</li>
<li>file_on表：文件存放在哪些存储设备</li>
<li>file_to_delete2表：删除队列表，升级后以前的不用了</li>
<li>file_to_queue表：type=1是fsck队列，type=2是rebalance队列</li>
<li>fsck_log表：fsck日志表，TYPE很多很诡异，参考<a href="/blog/2012/09/29/mogilefsde-fscktan-jiu/">fsk探究</a></li>
<li>file_to_replicate表：复制队列</li>
</ol>


<h4>问题总结</h4>

<ul>
<li>怀疑file_on表会有慢查询，其实不会太慢，因为Innodb默认asc排序</li>
</ul>


<p>```</p>

<h1>file_on的索引情况</h1>

<p>PRIMARY KEY (<code>fid</code>,<code>devid</code>),KEY <code>devid</code> (<code>devid</code>)</p>

<h1>下面的语句是不会慢的</h1>

<p>select * from file_on where devid = ? and fid > ? order by fid asc limit 100
```</p>

<ul>
<li>怀疑多个replicate队列同时操作同一个fid时是否会出现bug，其实不会，因为replicate使用mysql的get_lock(fid),release_lock(fid)</li>
</ul>


<h3>Utilities</h3>

<ol>
<li>mogadm：该工具直接管理mogilefs的主机、设备、域、类、从数据库、配置、fsck、rebalance</li>
<li>mogstat：观察fsck,rebalance,replication,delete运行状况</li>
<li>mogfiledebug：查看文件存储信息，也可以查file_on表</li>
<li>mogfetch：导出指定的文件</li>
<li>mogdelete：删除指定的文件</li>
<li>mogrename：更改文件的key</li>
<li>mogupload：插入一个文件</li>
<li>moglistfids，moglistkeys：批量列出记录，自己写脚本时可以使用</li>
</ol>


<h3>Telnet</h3>

<ol>
<li>!version：显示mogilefs版本</li>
<li>!recent：显示当前query执行时间（可做监控）</li>
<li>!queue：显示等待执行的查询（可做监控）</li>
<li>!stats：从tracker启动开始就记录的一些累加信息和实时信息，比如处理请求的总数、job队列当前记录数、当前等待执行的请求的个数等</li>
<li>!watch：显示<code>警告</code>和<code>错误</code>信息（可做监控）</li>
<li>!jobs：显示当前各个job的个数</li>
<li>!want：<code>动态调整</code>job个数</li>
<li>!to：不常用，向子进程发送消息，用来调试的</li>
<li>!shutdown：关闭所有mogilefsd进程</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MogileFS的replicate进程分析]]></title>
    <link href="http://www.wanghd.com/blog/2012/10/16/mogilefsde-replicatefen-xi/"/>
    <updated>2012-10-16T15:47:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/10/16/mogilefsde-replicatefen-xi</id>
    <content type="html"><![CDATA[<h4>基本流程</h4>

<ol>
<li>从replicate queue里获取需要处理数据,进行循环</li>
<li>执行真正的【replicate操作】，操作时会锁住这个fid，然后返回结果【下面会对该操作具体分析】</li>
<li>返回没问题，删除队列并释放锁</li>
<li>返回failed_getting_lock说明正在处理了</li>
<li>返回no_source说明file_on表上没有关于该文件的记录，nexttry设置为最大并释放锁</li>
<li>返回too_happy说明devcount > mindevcount，会尝试删除多余的并释放锁（前提是文件存在，所以不会修复file_on有，文件丢失的情况）</li>
<li>如果以上都不满足，nexttry根据规则增加，failcount递增并释放锁</li>
</ol>


<h4>replicate操作分析</h4>

<ul>
<li>简单说replicate操作就是取得合适的device进行复制，合适的意思是尽量避免同一个host的device，没办法才用同一个host的device，有错误就返回具体信息</li>
<li>replicate操作才是真正的复制，代码比较多，但是不难理解（难点都会有注释）</li>
</ul>


<!-- more -->


<p>```perl
sub replicate {</p>

<pre><code>my ($fid, %opts) = @_;      #参数赋值
$fid = MogileFS::FID-&gt;new($fid) unless ref $fid;   #实例fid对象
my $fidid = $fid-&gt;id; #fid的id

debug("Replication for $fidid called, opts=".join(',',keys(%opts))) if $Mgd::DEBUG &gt;= 2;


my $errref    = delete $opts{'errref'};  #错误消息的引用
my $no_unlock = delete $opts{'no_unlock'};  #上锁,使用Mysql的锁,get_lock和release_lock
#复制源，复制到哪些设备，排除的设备，避免的设备
my $fixed_source = delete $opts{'source_devid'};
my $mask_devids  = delete $opts{'mask_devids'}  || {};
my $avoid_devids = delete $opts{'avoid_devids'} || {};
my $target_devids = delete $opts{'target_devids'} || []; # inverse of avoid_devids.
die "unknown_opts" if %opts;
die unless ref $mask_devids eq "HASH";

my $sdevid; #下面会看到，就是复制源

my $sto = Mgd::get_store();
#释放锁的函数release_lock(name)
my $unlock = sub {
    $sto-&gt;note_done_replicating($fidid);
};

#这是一个返回函数，返回结果用的
my $retunlock = sub {
    my $rv = shift;
    my ($errmsg, $errcode);
    if (@_ == 2) {
        ($errcode, $errmsg) = @_;
        $errmsg = "$errcode: $errmsg"; # include code with message
    } else {
        ($errmsg) = @_;
    }
    $$errref = $errcode if $errref;

    my $ret;
    if ($errcode &amp;&amp; $errcode eq "failed_getting_lock") {
        # don't emit a warning with error() on lock failure.  not
        # a big deal, don't scare people.
        $ret = 0;
    } else {
        $ret = $rv ? $rv : error($errmsg);
    }
    if ($no_unlock) {
        die "ERROR: must be called in list context w/ no_unlock" unless wantarray;
        return ($ret, $unlock);
    } else {
        die "ERROR: must not be called in list context w/o no_unlock" if wantarray;
        $unlock-&gt;();
        return $ret;
    }
};

# hashref of devid -&gt; MogileFS::Device所有的device
my $devs = Mgd::device_factory()-&gt;map_by_id
    or die "No device map";

#错误话就调用retunlock 
return $retunlock-&gt;(0, "failed_getting_lock", "Unable to obtain lock for fid $fidid")
    unless $sto-&gt;should_begin_replicating_fidid($fidid);#这里获取mysql的锁 get_lock(name,timeout),name里fidid

# if the fid doesn't even exist, consider our job done!  no point
# replicating file contents of a file no longer in the namespace.
#没有fid返回
return $retunlock-&gt;("nofid") unless $fid-&gt;exists;

#Class.pm对象
my $cls = $fid-&gt;class;
#策略对象MogileFS::ReplicationPolicy::MultipleHosts
my $polobj = $cls-&gt;repl_policy_obj;

# learn what this devices file is already on
#所有设备
my @on_devs;         # all devices fid is on, reachable or not.
#排除dead和drain的设备
my @on_devs_tellpol; # subset of @on_devs, to tell the policy class about
#可读的设备
my @on_up_devid;     # subset of @on_devs:  just devs that are readable
#设置上面的数组
foreach my $devid ($fid-&gt;devids) {
    my $d = Mgd::device_factory()-&gt;get_by_id($devid)
        or next;
    #fid在哪些dev上
    push @on_devs, $d;
    #should_hava_files表示状态不为drain或者dead
    if ($d-&gt;dstate-&gt;should_have_files &amp;&amp; ! $mask_devids-&gt;{$devid}) {
        push @on_devs_tellpol, $d;
    }
    #有read权限
    if ($d-&gt;dstate-&gt;can_read_from) {
        push @on_up_devid, $devid;
    }
}
#如果一个设备都没，就返回
return $retunlock-&gt;(0, "no_source",   "Source is no longer available replicating $fidid") if @on_devs == 0;
return $retunlock-&gt;(0, "source_down", "No alive devices available replicating $fidid") if @on_up_devid == 0;

#fixed_source设置错误，根本就没有
if ($fixed_source &amp;&amp; ! grep { $_ == $fixed_source } @on_up_devid) {
    error("Fixed source dev$fixed_source requested for $fidid but not available. Trying other devices");
}

#错误的设备记录，下面循环里就不会再使用了
my %dest_failed;    # devid -&gt; 1 for each devid we were asked to copy to, but failed.
my %source_failed;  # devid -&gt; 1 for each devid we had problems reading from.
#用来标记真的复制了，下面的循环会使用
my $got_copy_request = 0;  # true once replication policy asks us to move something somewhere
my $copy_err;

#过滤复制到哪些设备
my $dest_devs = $devs;
if (@$target_devids) {
    $dest_devs = {map { $_ =&gt; $devs-&gt;{$_} } @$target_devids};
}

my $rr;  #MogileFS::ReplicationRequest对象
#开始循环复制，因为会有可能要复制3份的嘛。
while (1) {
    #MogileFS::ReplicationPolicy::MultipleHosts的replicate_to
    #取得ReplicationRequest对象【该对象是通过ReplicationPolicy::MultipleHosts策略生成的】
    #该对象会有4种返回值，分别是，1：对象形式，说明需要并可以复制。2：tmp_no_answer，没有可选择的device。
    #3：all_good，一切OK。4：too_good，好过头了呀。
    $rr = rr_upgrade($polobj-&gt;replicate_to(
                                           fid       =&gt; $fidid, #fidid
                                           on_devs   =&gt; \@on_devs_tellpol, # all device objects fid is on, dead or otherwise
                                           all_devs  =&gt; $dest_devs, #所有的dev，如果有target_devids的话那就用target的咯
                                           failed    =&gt; \%dest_failed, #失败信息
                                           min       =&gt; $cls-&gt;mindevcount, #最小设备
                                           ));
    #是happy就跳出，跳出会有后续处理的
    last if $rr-&gt;is_happy;

    #经过过滤的dev
    my @ddevs;  # dest devs, in order of preference
    #选择出来的devid
    my $ddevid; # dest devid we've chosen to copy to
    #这里设置ddevs,其实就是host不同的设备
    if (@ddevs = $rr-&gt;copy_to_one_of_ideally) {
        #过滤掉不希望的
        if (my @not_masked_ids = (grep { ! $mask_devids-&gt;{$_} &amp;&amp;
                                         ! $avoid_devids-&gt;{$_}
                                     }
                                  map { $_-&gt;id } @ddevs)) {
            $ddevid = $not_masked_ids[0]; #拿一个放到ddevid
        } else {
            return $retunlock-&gt;("would_worsen");
        }
    } elsif (@ddevs = $rr-&gt;copy_to_one_of_desperate) { #没有不同的host，没办法同一个host也行啊
        # TODO: reschedule a replication for 'n' minutes in future, or
        # when new hosts/devices become available or change state
        $ddevid = $ddevs[0]-&gt;id;
    } else {
        #跳出了呀，
        last;
    }
    #标记一下真的复制了
    $got_copy_request = 1;

    # replication policy shouldn't tell us to put a file on a device
    # we've already told it that we've failed at.  so if we get that response,
    # the policy plugin is broken and we should terminate now.
    #不在错误数组里
    if ($dest_failed{$ddevid}) {
        return $retunlock-&gt;(0, "policy_error_doing_failed",
                            "replication policy told us to do something we already told it we failed at while replicating fid $fidid");
    }

    # replication policy shouldn't tell us to put a file on a
    # device that it's already on.  that's just stupid.
    #已经在这file_on上了么，不行的呀
    if (grep { $_-&gt;id == $ddevid } @on_devs) {
        return $retunlock-&gt;(0, "policy_error_already_there",
                            "replication policy told us to put fid $fidid on dev $ddevid, but it's already there!");
    }

    # find where we're replicating from
    #这里开始设置复制源
    {
        # TODO: use an observed good device+host as source to start.
        #排除掉错误源
        my @choices = grep { ! $source_failed{$_} } @on_up_devid;
        return $retunlock-&gt;(0, "source_down", "No devices available replicating $fidid") unless @choices;
        #如果有fixed_source那就用，没有么就随即选一个吧
        if ($fixed_source &amp;&amp; grep { $_ == $fixed_source } @choices) {
            $sdevid = $fixed_source;
        } else {
            @choices = List::Util::shuffle(@choices);
            MogileFS::run_global_hook('replicate_order_final_choices', $devs, \@choices);
            $sdevid = shift @choices;
        }
    }

    #是子进程的判断
    my $worker = MogileFS::ProcManager-&gt;is_child or die;
    #校验和，不用的呀，不考虑
    my $digest = Digest-&gt;new($cls-&gt;hashname) if $cls-&gt;hashtype;
    #真的复制了
    my $rv = http_copy(
                       sdevid       =&gt; $sdevid,
                       ddevid       =&gt; $ddevid,
                       fid          =&gt; $fidid,
                       rfid         =&gt; $fid,
                       expected_len =&gt; undef,  # FIXME: get this info to pass along
                       errref       =&gt; \$copy_err,
                       callback     =&gt; sub { $worker-&gt;still_alive; },
                       digest       =&gt; $digest,
                       );
    die "Bogus error code: $copy_err" if !$rv &amp;&amp; $copy_err !~ /^(?:src|dest)_error$/;
    #如果错误了，设置失败数组，next等于其他语言的continue呀，继续找其他的
    unless ($rv) {
        error("Failed copying fid $fidid from devid $sdevid to devid $ddevid (error type: $copy_err)");
        if ($copy_err eq "src_error") {
            $source_failed{$sdevid} = 1;

            if ($fixed_source &amp;&amp; $fixed_source == $sdevid) {
                error("Fixed source dev$fixed_source was requested for $fidid but failed: will try other sources");
            }

        } else {
            $dest_failed{$ddevid} = 1;
        }
        next;
    }
    #复制成功了，开始插入数据了
    my $dfid = MogileFS::DevFID-&gt;new($ddevid, $fid);
    $dfid-&gt;add_to_db;
    if ($digest &amp;&amp; !$fid-&gt;checksum) {
        $sto-&gt;set_checksum($fidid, $cls-&gt;hashtype, $digest-&gt;digest);
    }

    #设置一下变量，加入要复制3分是应该再继续复制的
    push @on_devs, $devs-&gt;{$ddevid};
    push @on_devs_tellpol, $devs-&gt;{$ddevid};
    push @on_up_devid, $ddevid;
}

# We are over replicated. Let caller decide if it should rebalance.
#好过头了
if ($rr-&gt;too_happy) {
    return $retunlock-&gt;(0, "too_happy", "fid $fidid is on too many devices");
}
#这是满足策略的情况
if ($rr-&gt;is_happy) {
    return $retunlock-&gt;(1) if $got_copy_request;
    #没有地方去复制了
    return $retunlock-&gt;("lost_race");  # some other process got to it first.  policy was happy immediately.
}
#应该不会走到这里了
return $retunlock-&gt;(0, "policy_no_suggestions",
                    "replication policy ran out of suggestions for us replicating fid $fidid");
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mogilefs文件路径规则]]></title>
    <link href="http://www.wanghd.com/blog/2012/10/11/mogilefswen-jian-lu-jing-gui-ze/"/>
    <updated>2012-10-11T16:16:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/10/11/mogilefswen-jian-lu-jing-gui-ze</id>
    <content type="html"><![CDATA[<h3>同事问我mogilefs文件路径的规律是什么</h3>

<ul>
<li>以前有看到过，但是没有记录，一下子就被问悶了，突然发现就记录一下</li>
<li>当fid长度不足10时，前置补0到长度为10,假设补好后的结果为0258693147</li>
<li>通过正则把path切割成0/258/693/147这样</li>
<li>最后的路径结果是：/设备/0/258/693/147/0258693147.fid</li>
</ul>


<p>```perl
sub uri_path {</p>

<pre><code>my $self = shift;
my $devid = $self-&gt;{devid};
my $fidid = $self-&gt;{fidid};

my $nfid;
my $len = length $fidid;
if ($len &lt; 10) {
    $nfid = '0' x (10 - $len) . $fidid;
} else {
    $nfid = $fidid;
}   
my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

return "/dev$devid/$b/$mmm/$ttt/$nfid.fid";
</code></pre>

<p>}
```</p>

<h3>总结一下</h3>

<ul>
<li>这个算法效率很高，并且可以把文件平均分配到目录下</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mogilefs设备权重算法]]></title>
    <link href="http://www.wanghd.com/blog/2012/10/09/mogilefsshe-bei-quan-zhong-suan-fa/"/>
    <updated>2012-10-09T11:07:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/10/09/mogilefsshe-bei-quan-zhong-suan-fa</id>
    <content type="html"><![CDATA[<h3>遇到的问题</h3>

<ul>
<li>有几块设备已经剩余10%容量，有几块设备剩余75%容量，为什么75%的util相当高呢</li>
<li>原本理解mogilefs平均分配新文件到设备上，猜想应该是不对的</li>
</ul>


<h3>看看mogilefs到底是怎么做的呢</h3>

<ul>
<li>处理文件是Query.pl干的，确认新建文件是cmd_create_open函数所为</li>
</ul>


<p>```perl
sub cmd_create_open {</p>

<pre><code>#略

#默认情况下设备的选择是从这开始的，参数是所有设备
@devices = sort_devs_by_freespace(Mgd::device_factory()-&gt;get_all); 

#略
</code></pre>

<p>}
```</p>

<ul>
<li>sort_devs_by_freespace用剩余百分比做为权重，生成一个二维数组做参数[前20个]</li>
<li>真正的返回值是通过MogileFS::Util::weighted_list进行权重计算</li>
</ul>


<p>```perl
sub sort_devs_by_freespace {</p>

<pre><code>my @devices_with_weights = map { #生成二维数组，剩余大小用来做权重
    [$_, 100 * $_-&gt;percent_free]
} sort {  #排序，从大到小排序
    $b-&gt;percent_free &lt;=&gt; $a-&gt;percent_free;
} grep {  #过滤设备，只要可以新建文件的，就是状态为alive的
    $_-&gt;should_get_new_files;
} @_;

my @list =
    MogileFS::Util::weighted_list(splice(@devices_with_weights, 0, 20));

return @list;
</code></pre>

<p>}
```</p>

<ul>
<li>这里才是算法的核心，让容量多的多放点文件，但当容量很大时基本随即，做个例子会比较直观</li>
<li>假设有两个设备，剩余的容量分别是10和75</li>
<li>那么sum就是85，如果乘以随机数的话可能是8.5(0.1)或者是76.5(0.9)</li>
<li>如果是8.5，那么75就大于8.5了，先返回了【并且这种概率大】</li>
<li>如果是76.5，那么75就不大于76.5了, 则返回另一个【这种概率小】</li>
</ul>


<p>```perl
sub weighted_list (@) {</p>

<pre><code>my @list = grep { $_-&gt;[1] &gt; 0 } @_; #排除掉等于0的 
my @ret; #初始化返回数组

my $sum = 0;
$sum += $_-&gt;[1] foreach @list; #累加剩余容量

my $getone = sub {
    return shift(@list)-&gt;[0]
        if scalar(@list) == 1; #只有一个了，直接返回

    my $val = rand() * $sum; #总容量乘以0到1的随机数
    my $curval = 0;
    for (my $idx = 0; $idx &lt; scalar(@list); $idx++) {
        my $item = $list[$idx];
        $curval += $item-&gt;[1]; #累加进去,保证肯定有返回
        if ($curval &gt;= $val) { #如果curval比随机乘积大
            my ($ret) = splice(@list, $idx, 1); #切割出来
            $sum -= $item-&gt;[1]; #从总容量里减去
            return $ret-&gt;[0];   #返回这个设备
        }   
    }   
};  

push @ret, $getone-&gt;() while @list; #循环执行getone，加到返回数组
return @ret;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mogilefs fsck探究]]></title>
    <link href="http://www.wanghd.com/blog/2012/09/29/mogilefsde-fscktan-jiu/"/>
    <updated>2012-09-29T15:13:00+08:00</updated>
    <id>http://www.wanghd.com/blog/2012/09/29/mogilefsde-fscktan-jiu</id>
    <content type="html"><![CDATA[<h3>fsck的作用</h3>

<ul>
<li>检查mogilefs文件的健康程度，检查的维度有devcount,file_on表,文件长度，校验和（可选）</li>
<li>如果文件丢失，通过路径尝试全设备扫描去查找该文件【只是通过路径去找】</li>
</ul>


<h3>使用fsck时，碰到的问题:队列保持不变，无法处理后续的文件</h3>

<p><code>
//启动fsck
mogadm fsck start  
//查看fsck状态，问题出现：进度不变,无法进一步检查文件
mogadm fsck status
//查看数据库里的队列，发现队列一直保持，没有被处理
select count(*) from file_to_queue where type=1 （type=1代表fsck队列，type=2代表rebalance队列）;
</code></p>

<h3>结论（先给出结论，后面有具体的分析流程）</h3>

<ul>
<li>随意取得队列中的某一条记录的devcount等于3，过去操作造成的</li>
<li>mindevcount却等于2，这会让fsck进行修复</li>
<li>在修复时，发现3个设备中有一个设备是不可达的，状态也不是dead，返回无法处理，fsck不会把该记录从队列中删除，因为他期望你尽快修复该设备或者设置为dead</li>
<li>解决方法有3个，第一种就是恢复或dead该设备【推荐】，第二种比较山寨,改代码删队列，第三种直接修改数据库,风险较大</li>
</ul>


<h3>mogadm fsck status详情</h3>

<p>```
   Running: 运行状态</p>

<pre><code>Status: 完成度
  Time: 执行时间
</code></pre>

<p>Check Type: 检查的策略【可以通过fsck_opt_policy_only修改】</p>

<p>NOPA: file_on表里一个都没
POVI: 违反策略
MISS: 在某个设备上没有找到文件
BLEN: file表里的length和磁盘上的文件大小不匹配
GONE: 无法修复了
SRCH: 开始全设备扫描
FOND: 全设备扫描后找了该文件
REPL: 加入复制队列，复制一份文件
BCNT: file表里的devcount不正确
```</p>

<!-- more -->


<h3>MogileFS::Worker::Fsck的work方法分析</h3>

<ul>
<li>因为之前有分析过MogileFS启动源码，所以知道fsck子进程启动就调用MogileFS::Worker::Fsck里的work方法</li>
<li>里面循环调用了最关键的check_fid方法来检查fid对象，返回的结果是已经处理（HANDLED）和没办法处理（STALLED）</li>
</ul>


<p>```perl
sub work {</p>

<pre><code>my $self = shift; #perl面向对象获取自己的引用
POSIX::nice(10);  #调整进程的优先级

my $sto         = Mgd::get_store(); #获取操作数据库的对象

#2秒调用一次这个匿名方法
every(2.0, sub {
    my $sleep_set = shift; #一个调整sleep时间的函数，下面可以看到设置为0不去调整，就用2秒
    $nowish = time();      #当前时间
    local $Mgd::nowish = $nowish; #零时变量

    my $queue_todo = $self-&gt;queue_todo('fsck');    #获取fsck队列里的数据
    $self-&gt;send_to_parent('worker_bored 50 fsck'); #告诉父进程，我还活着
    return unless @{$queue_todo};                  #没有需要需要处理就返回
    return unless $self-&gt;validate_dbh;             #验证db，无法连接就退出

    my @fids = ();  #fids数组，用来存放文件的id,也是数据库里文件的唯一标识 
    #遍历队列的数据，$todo就是数据库里的信息 type=1
    while (my $todo = shift @{$queue_todo}) {        
        #new 一个fid对象，只是new，还没有读取fid信息
        my $fid = MogileFS::FID-&gt;new($todo-&gt;{fid});  
        #这里才是通过查file表，判断他是不是存在
        unless ($fid-&gt;exists) {                      
            #从file_to_queue表里删除
            $sto-&gt;delete_fid_from_file_to_queue($fid-&gt;id, FSCK_QUEUE); 
        }
        push(@fids, $fid); #如果有，那就把fid对象放到数组里
    }
    return unless @fids;   #如果没有需要处理的就返回了 
    #从setting表里读取fsck_opt_policy_only配置
    #1代表只检查数据库信息，0代表检查数据信息和文件长度
    $self-&gt;{opt_nostat} = MogileFS::Config-&gt;server_setting('fsck_opt_policy_only')     || 0;
    #从setting表里读取fsck_checksum配置,代表是否需要检查校验和,可选值为md5,sha-1,off
    my $alg = MogileFS::Config-&gt;server_setting_cached("fsck_checksum");
    if (defined($alg) &amp;&amp; $alg eq "off") {   #如果没有定义或为off
        $self-&gt;{opt_checksum} = "off";      #那就设置成off,不检查
    } else {
        #验证一下是否为md5 或 sha-1,如果不是那就设置为0
        $self-&gt;{opt_checksum} = MogileFS::Checksum-&gt;valid_alg($alg) ? $alg : 0;
    }
    MogileFS::FID-&gt;mass_load_devids(@fids); #通过file_on表获取每个fid存放在哪些device上
    $sleep_set-&gt;(0); #微调sleep时间，写死为0，可能是调试用的

    foreach my $fid (@fids) {               #循环每一个fid对象
        #这里是关键是亮点，是接下去分析的入口
        #返回的结果是已经处理（HANDLED）和没办法处理（STALLED）
        if (!$self-&gt;check_fid($fid)) {      
            #如果运行到了这里，说明跟磁盘有连通性的问题
            #最重要的是不会删除队列，放在里面以后再尝试
            #其实队列的卡住的问题就出在这里,接下去进入check_fid看看
            $self-&gt;still_alive;
            next;
        }
        #已经处理了，就可以删除队列里的数据了
        $sto-&gt;delete_fid_from_file_to_queue($fid-&gt;id, FSCK_QUEUE);
    }
});
</code></pre>

<p>}
```</p>

<h3>MogileFS::Worker::Fsck的check_fid方法分析</h3>

<ul>
<li>传入的参数是$fid是MogileFS::FID对象</li>
<li>返回0表示磁盘不可达（STALLED）</li>
<li>返回1代表fid对象已经被处理，不管这个fid是不是有问题，没问题就不处理，有问题就记录日志并修复</li>
<li>真正去修复一个fid对象的函数是fix_fid,接下去会分析</li>
<li>问题渐渐浮出水面，坏掉的设备没有被dead，或者直接删除掉设备有可能会让队列卡住</li>
</ul>


<p>```perl</p>

<h1>下面是返回值，被定义成常量</h1>

<p>use constant STALLED => 0;
use constant HANDLED => 1;
sub check_fid {</p>

<pre><code>my ($self, $fid) = @_;      #设置对象自己和fid对象

my $fix = sub {             #定义一个修复的数据的函数,只是定义，真正的调用在下面逻辑
    #fix_fid是最重要的函数用来修复fid对象，也是接下去需要分析的入口
    #这里使用了eval{}，这样可以捕获错误
    my $fixed = eval { $self-&gt;fix_fid($fid) }; 
    if (! defined $fixed) {                     #如果产生了错误
        #输出异常日志，我们的问题就会运行到这里输出这样的信息
        error("Fsck stalled for fid $fid: $@"); 
        #返回一个不会去删除队列的结果，造成队列积满
        #所以直接去fix_fid里查看错误的判断就可以知道为什么了
        return STALLED;
    }
    $fid-&gt;fsck_log(EV_CANT_FIX) if ! $fixed;  #记录日志，不可以修复,GONE
    $nowish = $self-&gt;still_alive;             #更新时间
    return HANDLED;                           #返回已经处理
};

unless ($fid-&gt;devids) {         #一个设备上都没有的话
    $fid-&gt;fsck_log(EV_NO_PATHS);#记录日志path都没 NOPA
    return $fix-&gt;();            #搜索所有设备作为最后的努力来定位它
}
#查找数据库file_on数量，要满足mindevcount，如果超过也属于不满足（神奇的too happy）
unless ($fid-&gt;devids_meet_policy) {     
    $fid-&gt;fsck_log(EV_POLICY_VIOLATION);#记录日志违反策略 POVI
    return $fix-&gt;();                    #尝试修复
}

#如果不skip_devcount，同时file_on和file里的devcount对不起来
unless (MogileFS::Config-&gt;server_setting_cached('skip_devcount') || scalar($fid-&gt;devids) == $fid-&gt;devcount) {
    $fid-&gt;fsck_log(EV_BAD_COUNT); #记录日志file表里devcount不正确
    return $fix-&gt;();              #尝试修复，其实是调用$fid-&gt;update_devcount();
}

#我们不使用，其实他是判断checksum表里是否有记录
if ($fid-&gt;class-&gt;hashtype &amp;&amp; ! $fid-&gt;checksum) { 
    return $fix-&gt;();        #尝试修复
}

#如果配置了fsck_opt_policy_only那就到此结束了,不会去判断文件长度和校验和了
#如果策略是这样，事故后的fsck就有意义了
return HANDLED if $self-&gt;{opt_nostat}; 
#如果配置检查校验和,默认不使用
if ($self-&gt;{opt_checksum} &amp;&amp; $self-&gt;{opt_checksum} ne "off") { 
    return $fix-&gt;(); #尝试修复
}

my $err; #记录错误的变量
#parallel_check_sizes会取得磁盘上文件的大小
#匿名的对比函数,第一个参数是设备,第二参数就是磁盘上文件的大小
my $rv = $self-&gt;parallel_check_sizes([ $fid-&gt;devfids ], sub {
    my ($dfid, $disk_size) = @_;            #devfid对象，和磁盘上文件的大小
    if (! defined $disk_size) {             #如果拿不到磁盘上文件的大小
        my $dev  = $dfid-&gt;device;           #设备对象
        if ($dev-&gt;dstate-&gt;is_perm_dead) {   #如果磁盘的状态是dead
            $err = "needfix";               #记录错误为需要修复
            return 0;                       #返回0
        }
        #输出连通性问题的日志
        error("Connectivity problem reaching device " . $dev-&gt;id . " on host " . $dev-&gt;host-&gt;ip . "\n");
        $err = "stalled";                   #记录错误为无法处理
        return 0;                           #返回0
    }
    return 1 if $disk_size == $fid-&gt;length; #file表里的length和磁盘上的大小一样,直接返回1
    $err = "needfix";                       #下面就是大小不一样了，记录错误为需要修复
    return 0;                               #返回0
});

if ($rv) {
    return ($fid-&gt;class-&gt;hashtype &amp;&amp; !($self-&gt;{opt_checksum} &amp;&amp; $self-&gt;{opt_checksum} eq "off"))
        ? $fix-&gt;() : HANDLED;               #不扯校验和了，直接返回已处理
} elsif ($err eq "stalled") {               
    #返回无法处理，也会造成队列堆积，因为file_on表里的device没有设置为dead
    return STALLED;
} elsif ($err eq "needfix") {
    #进行修复
    return $fix-&gt;();
} else {
    #这里应该不会执行到
    die "Unknown error checking fid sizes in parallel.\n";
}
</code></pre>

<p>}
```</p>

<h3>MogileFS::Worker::Fsck的fix_fid方法分析</h3>

<ul>
<li>该方法有可能会比较慢，因为file_on表上一条记录都没会尝试查找所有设备，【通过path】</li>
<li>die是由于设备连接性问题造成的，会引起队列堵死</li>
</ul>


<p>```
use constant CANT_FIX => 0; #不可以被修复
sub fix_fid {</p>

<pre><code>my ($self, $fid) = @_;                     #对象自己，fid对象
debug(sprintf("Fixing FID %d", $fid-&gt;id)); #调试信息，正在修复哪个fid

#通过file_on更新一下file表里的devcount; 
#这里学习了下mysql的get_lock
$fid-&gt;update_devcount;

#遍历devids属性生成多个devfid对象放到数组,其实就是file_on表
my @dfids = map { MogileFS::DevFID-&gt;new($_, $fid) } $fid-&gt;devids; 

my @good_devs;        #初始化好的设备
my @bad_devs;         #初始化坏的设备数组
my %already_checked;  #初始化已经检查过的设备hash

my $check_dfids = sub { #定义一个监测函数
    my $is_desperate_mode = shift; #是否全设备扫描

    foreach my $dfid (@dfids) { #遍历fid的devfid对象
        my $dev = $dfid-&gt;device;
        next if $already_checked{$dev-&gt;id}++; #已经检查过就跳过了

        #磁盘状态为dead，那就放到bad_devs里
        if ($dev-&gt;dstate-&gt;is_perm_dead) {
            push @bad_devs, $dev;
            next;
        }

        my $disk_size = $self-&gt;size_on_disk($dfid);  #获取磁盘上的文件大小
        #这里是我们产生问题的根源。。。设备不可达，也没设置成dead
        die "dev " . $dev-&gt;id . " unreachable" unless defined $disk_size;

        if ($disk_size == $fid-&gt;length) { #如果长度一样
            push @good_devs, $dfid-&gt;device; #加到好的设备里
            #如果是全设备扫描，那就等于发现了丢失文件，就可以返回了，不用继续查找了
            return if $is_desperate_mode; 
            next; #下一个,其他编程语言的continue
        }

        unless ($is_desperate_mode) { #如果不是全设备扫描
            if ($disk_size == -1) {
                #没有找到文件呀,MISS
                $fid-&gt;fsck_log(EV_FILE_MISSING, $dev);
            } else {
                #长度不正确呀,BLEN
                $fid-&gt;fsck_log(EV_BAD_LENGTH, $dev);
            }
        }

        push @bad_devs, $dfid-&gt;device; #增加到坏设备里
    }
};

$check_dfids-&gt;(); #调用上面的监测函数

unless (@good_devs) { # 如果一个好的都没
    #记录日志,全设备扫描 SRCH
    $fid-&gt;fsck_log(EV_START_SEARCH);
    #重新设置@dfids,全部的设备
    @dfids = List::Util::shuffle(
                                 map  { MogileFS::DevFID-&gt;new($_, $fid)  }
                                 grep { $_-&gt;dstate-&gt;should_fsck_search_on }
                                 Mgd::device_factory()-&gt;get_all
                                 );
    #重新再找一次,这次是全盘扫描模式
    $check_dfids-&gt;("desperate");

    # 不能修复了呀，找不到文件了
    return CANT_FIX unless @good_devs;
    # 如果能找到，记录日志,FOND
    $fid-&gt;fsck_log(EV_FOUND_FID);
    # 加到数据库里,就是file_on的表里
    $fid-&gt;note_on_device($good_devs[0]); 
}

# 循环坏的设备，删除掉file_on里的数据
foreach my $bdev (@bad_devs) {
    error("removing file_on mapping for fid=" . $fid-&gt;id . ", dev=" . $bdev-&gt;id);
    $fid-&gt;forget_about_device($bdev);
}

$fid-&gt;want_reload; #重新加载fid对象
# 如果还是没能满足策略，就就应该复制一份了呀
unless ($fid-&gt;devids_meet_policy) {
    #加入到replacte队列中
    $fid-&gt;enqueue_for_replication(in =&gt; 1);
    #记录日志 REPL
    $fid-&gt;fsck_log(EV_RE_REPLICATE);
    #返回已经处理
    return HANDLED;
}

# 更新devcount
unless(MogileFS::Config-&gt;server_setting_cached('skip_devcount') || scalar($fid-&gt;devids) == $fid-&gt;devcount) {
    $fid-&gt;update_devcount(); 
    $fid-&gt;fsck_log(EV_BAD_COUNT); #记录日志BCNT
}

return HANDLED;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
